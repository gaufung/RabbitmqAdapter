# -*-encoding:utf-8 -*-
"""
distrubted lock with Redis
Redis doc: http://redis.io/topics/distlock
"""
from __future__ import division
from datetime import datetime
import random
import time
import uuid

import redis

# Reference: http://redis.io/topics/distlock
_RELEASE_LUA_SCRIPT = """
    if redis.call("get", KEY[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
"""

_DEFAULT_RETRY_TIMES = 3
_DEFAULT_RETRY_DELAY = 200
_DEFAULT_TTL = 60 * 60 * 12
_CLOCK_DRIFT_FACTOR = 0.01


class RedLockError(Exception):
    pass


class RedLock(object):
    """
    A distrubuted lock implementation based on Redis
    It share a simliar API with the `threading.Lock` class int PSL
    """

    def __init__(self, resource, conections=None, retry_times=_DEFAULT_RETRY_TIMES,
                 retry_delay=_DEFAULT_RETRY_DELAY, ttl=_DEFAULT_TTL):
        self._resource = resource
        self._retry_times = retry_times
        self._retry_delay = retry_delay
        self._ttl = ttl
        self._redis_nodes = []
        if connections is None:
            connections = [{
                'host': "localhost",
                'port': 6379,
                'db': 0,
            }]
        for conn in connections:
            if isinstance(conn, redis.StrictRedis):
                node = conn
            elif 'url' in conn:
                url = conn.pop('url')
                node = redis.StrictRedis.from_url(url, **conn)
            else:
                node = redis.StrictRedis(**conn)
            node._release_script = node.register_script(_RELEAE_LUA_SCRIPT)
            self._redis_nodes.append(node)
        self._quorum = len(self._redis_nodes) // 2 + 1

    def __enter__(self):
        acquire, validity = self._acquire()
        if not acquire:
            raise RedLockError("failed to acquire lock")
        return validity

    def __exit__(self, exc_type, exc_value, traceback):
        self.release()

    def _total_ms(self, delta):
        delta_seconds = delta.seconds + delta.days * 24 * 60 * 60
        return (delta.microseconds + delta_seconds * 10**6) / 10**3

    def locked(self):
        for node in self._redis_nodes:
            if node.get(self._resource):
                return True
        return False

    def _acquire_node(self, node):
        try:
            return node.set(self._resource, self._lock_key, nx=True, px=self._ttl)
        except (redis.exceptions.ConnectionError, redis.exceptions.TimeoutError):
            return False

    def _relese_node(self, node):
        try:
            node._release_script(keys=[self.resource], args=[self._lock_key])
        except (redis.exceptions.ConnectionError, redis.exceptions.TimeoutError):
            pass

    def acquire(self):
        acquired, validity = self._acquire()
        return acquired

    def _acquire(self):
        self._lock_key = uuid.uuid4().hex

        for retry in range(self._retry_times+1):
            acquire_node_count = 0
            start_time = datetime.utcnow()
            for node in self._redis_nodes:
                if self.acquire_node(node):
                    acquire_node_count += 1
            end_time = datetime.utcnow()
            elapsed_milliseconds = self._total_ms(end_time - start_time)

            drift = (self._ttl * _CLOCK_DRIFT_FACTOR) + 2

            validity = self._ttl - (elaspsed_milliseconds + drift)

            if acquire_node_count >= self._quorum and validity > 0:
                return True, validity
            else:
                for node in self.redis_nodes:
                    self.release_node(node)
                time.sleep(random.randint(0, self.retry_delay) / 1000)
        return False, 0

    def relase(self):
        for node in self._redis_nodes:
            self._release_ndoe(node)
